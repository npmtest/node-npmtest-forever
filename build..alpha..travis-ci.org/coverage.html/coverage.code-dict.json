{"/home/travis/build/npmtest/node-npmtest-forever/test.js":"/* istanbul instrument in package npmtest_forever */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-forever/lib.npmtest_forever.js":"/* istanbul instrument in package npmtest_forever */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_forever = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_forever = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-forever/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-forever && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_forever */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_forever\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_forever.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_forever.rollup.js'] =\n            local.assetsDict['/assets.npmtest_forever.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_forever.__dirname + '/lib.npmtest_forever.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever/lib/forever.js":"/*\n * forever.js: Top level include for the forever module\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    events = require('events'),\n    exec = require('child_process').exec,\n    spawn = require('child_process').spawn,\n    cliff = require('cliff'),\n    nconf = require('nconf'),\n    nssocket = require('nssocket'),\n    timespan = require('timespan'),\n    utile = require('utile'),\n    winston = require('winston'),\n    mkdirp = utile.mkdirp,\n    async = utile.async;\n\nvar forever = exports;\n\n//\n// Setup `forever.log` to be a custom `winston` logger.\n//\nforever.log = new (winston.Logger)({\n  transports: [\n    new (winston.transports.Console)()\n  ]\n});\n\nforever.log.cli();\n\n//\n// Setup `forever out` for logEvents with `winston` custom logger.\n//\nforever.out = new (winston.Logger)({\n  transports: [\n    new (winston.transports.Console)()\n  ]\n});\n\n//\n// ### Export Components / Settings\n// Export `version` and important Prototypes from `lib/forever/*`\n//\nforever.initialized  = false;\nforever.kill         = require('forever-monitor').kill;\nforever.checkProcess = require('forever-monitor').checkProcess;\nforever.root         = process.env.FOREVER_ROOT || path.join(process.env.HOME || process.env.USERPROFILE || '/root', '.forever');\nforever.config       = new nconf.File({ file: path.join(forever.root, 'config.json') });\nforever.Forever      = forever.Monitor = require('forever-monitor').Monitor;\nforever.Worker       = require('./forever/worker').Worker;\nforever.cli          = require('./forever/cli');\n\n//\n// Expose version through `pkginfo`\n//\nexports.version = require('../package').version;\n\n//\n// ### function getSockets (sockPath, callback)\n// #### @sockPath {string} Path in which to look for UNIX domain sockets\n// #### @callback {function} Continuation to pass control to when complete\n// Attempts to read the files from `sockPath` if the directory does not exist,\n// then it is created using `mkdirp`.\n//\nfunction getSockets(sockPath, callback) {\n  var sockets;\n\n  try {\n    sockets = fs.readdirSync(sockPath);\n  }\n  catch (ex) {\n    if (ex.code !== 'ENOENT') {\n      return callback(ex);\n    }\n\n    return mkdirp(sockPath, '0755', function (err) {\n      return err ? callback(err) : callback(null, []);\n    });\n  }\n\n  callback(null, sockets);\n}\n\n//\n// ### function getAllProcess (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Returns all data for processes managed by forever.\n//\nfunction getAllProcesses(callback) {\n  var sockPath = forever.config.get('sockPath');\n\n  function getProcess(name, next) {\n    var fullPath = path.join(sockPath, name),\n        socket = new nssocket.NsSocket();\n\n    if (process.platform === 'win32') {\n      // it needs the prefix\n      fullPath = '\\\\\\\\.\\\\pipe\\\\' + fullPath;\n    }\n\n    socket.connect(fullPath, function (err) {\n      if (err) {\n        next(err);\n      }\n\n      socket.dataOnce(['data'], function (data) {\n        data.socket = fullPath;\n        next(null, data);\n        socket.end();\n      });\n\n      socket.send(['data']);\n    });\n\n    socket.on('error', function (err) {\n      if (err.code === 'ECONNREFUSED') {\n        fs.unlink(fullPath, function () {\n          next();\n        });\n      }\n      else {\n        next();\n      }\n    });\n  }\n\n  getSockets(sockPath, function (err, sockets) {\n    if (err || (sockets && sockets.length === 0)) {\n      return callback(err);\n    }\n\n    async.map(sockets, getProcess, function (err, processes) {\n      callback(err, processes.filter(Boolean));\n    });\n  });\n}\n\n//\n// ### function getAllPids ()\n// Returns the set of all pids managed by forever.\n// e.x. [{ pid: 12345, foreverPid: 12346 }, ...]\n//\nfunction getAllPids(processes) {\n  return !processes ? null : processes.map(function (proc) {\n    return {\n      pid: proc.pid,\n      foreverPid: proc.foreverPid\n    };\n  });\n}\n\n//\n// ### function stopOrRestart (action, event, format, target)\n// #### @action {string} Action that is to be sent to target(s).\n// #### @event {string} Event that will be emitted on success.\n// #### @format {boolean} Indicated if we should CLI format the returned output.\n// #### @target {string} Index or script name to stop. Optional.\n// ####                  If not provided -> action will be sent to all targets.\n// Returns emitter that you can use to handle events on failure or success (i.e 'error' or <event>)\n//\nfunction stopOrRestart(action, event, format, target) {\n  var emitter = new events.EventEmitter();\n\n  function sendAction(proc, next) {\n    var socket = new nssocket.NsSocket();\n\n    function onMessage(data) {\n      //\n      // Cleanup the socket.\n      //\n      socket.undata([action, 'ok'],    onMessage);\n      socket.undata([action, 'error'], onMessage);\n      socket.end();\n\n      //\n      // Messages are only sent back from error cases. The event\n      // calling context is available from `nssocket`.\n      //\n      var message = data && data.message,\n          type    = this.event.slice().pop();\n\n      //\n      // Remark (Tjatse): This message comes from `forever-monitor`, the process is marked\n      // as `STOPPED`: message: Cannot stop process that is not running.\n      //\n      // Remark (indexzero): We should probably warn instead of emitting an error in `forever-monitor`,\n      // OR handle that error in `bin/worker` for better RPC.\n      //\n      return type === 'error' && /is not running/.test(message)\n        ? next(new Error(message))\n        : next(null, data);\n    }\n\n    socket.connect(proc.socket, function (err) {\n      if (err) {\n        next(err);\n      }\n\n      socket.dataOnce([action, 'ok'],    onMessage);\n      socket.dataOnce([action, 'error'], onMessage);\n      socket.send([action]);\n    });\n\n    //\n    // Remark (indexzero): This is a race condition, but unlikely to ever hit since\n    // if the socket errors we will never get any data in the first place...\n    //\n    socket.on('error', function (err) {\n      next(err);\n    });\n  }\n\n\n  getAllProcesses(function (err, processes) {\n    if (err) {\n      return process.nextTick(function () {\n        emitter.emit('error', err);\n      });\n    }\n\n    var procs;\n    if (target !== undefined && target !== null) {\n      if (isNaN(target)) {\n        procs = forever.findByScript(target, processes);\n      }\n      procs = procs\n        || forever.findById(target, processes)\n        || forever.findByIndex(target, processes)\n        || forever.findByUid(target, processes)\n        || forever.findByPid(target, processes);\n    }\n    else {\n      procs = processes;\n    }\n\n    if (procs && procs.length > 0) {\n      async.map(procs, sendAction, function (err, results) {\n        if (err) {\n          emitter.emit('error', err);\n        }\n\n        //\n        // Remark (indexzero): we should do something with the results.\n        //\n        emitter.emit(event, forever.format(format, procs));\n      });\n    }\n    else {\n      process.nextTick(function () {\n        emitter.emit('error', new Error('Cannot find forever process: ' + target));\n      });\n    }\n  });\n\n  return emitter;\n}\n\n//\n// ### function load (options, [callback])\n// #### @options {Object} Options to load into the forever module\n// Initializes configuration for forever module\n//\nforever.load = function (options) {\n  // memorize current options.\n  this._loadedOptions = options;\n\n  //\n  // Setup the incoming options with default options.\n  //\n  options           = options           || {};\n  options.loglength = options.loglength || 100;\n  options.logstream = options.logstream || false;\n  options.root      = options.root      || forever.root;\n  options.pidPath   = options.pidPath   || path.join(options.root, 'pids');\n  options.sockPath  = options.sockPath  || path.join(options.root, 'sock');\n\n  //\n  // If forever is initalized and the config directories are identical\n  // simply return without creating directories\n  //\n  if (forever.initialized && forever.config.get('root') === options.root &&\n    forever.config.get('pidPath') === options.pidPath) {\n    return;\n  }\n\n  forever.config = new nconf.File({ file: path.join(options.root, 'config.json') });\n\n  //\n  // Try to load the forever `config.json` from\n  // the specified location.\n  //\n  try {\n    forever.config.loadSync();\n  }\n  catch (ex) { }\n\n  //\n  // Setup the columns for `forever list`.\n  //\n  options.columns  = options.columns  || forever.config.get('columns');\n  if (!options.columns) {\n    options.columns = [\n      'uid', 'command', 'script', 'forever', 'pid', 'id', 'logfile', 'uptime'\n    ];\n  }\n\n  forever.config.set('root', options.root);\n  forever.config.set('pidPath', options.pidPath);\n  forever.config.set('sockPath', options.sockPath);\n  forever.config.set('loglength', options.loglength);\n  forever.config.set('logstream', options.logstream);\n  forever.config.set('columns', options.columns);\n\n  //\n  // Setup timestamp to event logger\n  //\n  forever.out.transports.console.timestamp = forever.config.get('timestamp') === 'true';\n\n  //\n  // Attempt to see if `forever` has been configured to\n  // run in debug mode.\n  //\n  options.debug = options.debug || forever.config.get('debug') || false;\n\n  if (options.debug) {\n    //\n    // If we have been indicated to debug this forever process\n    // then setup `forever._debug` to be an instance of `winston.Logger`.\n    //\n    forever._debug();\n  }\n\n  //\n  // Syncronously create the `root` directory\n  // and the `pid` directory for forever. Although there is\n  // an additional overhead here of the sync action. It simplifies\n  // the setup of forever dramatically.\n  //\n  function tryCreate(dir) {\n    try {\n      fs.mkdirSync(dir, '0755');\n    }\n    catch (ex) { }\n  }\n\n  tryCreate(forever.config.get('root'));\n  tryCreate(forever.config.get('pidPath'));\n  tryCreate(forever.config.get('sockPath'));\n\n  //\n  // Attempt to save the new `config.json` for forever\n  //\n  try {\n    forever.config.saveSync();\n  }\n  catch (ex) { }\n\n  forever.initialized = true;\n};\n\n//\n// ### @private function _debug ()\n// Sets up debugging for this forever process\n//\nforever._debug = function () {\n  var debug = forever.config.get('debug');\n\n  if (!debug) {\n    forever.config.set('debug', true);\n    forever.log.add(winston.transports.File, {\n      level: 'silly',\n      filename: path.join(forever.config.get('root'), 'forever.debug.log')\n    });\n  }\n};\n\n//\n// Ensure forever will always be loaded the first time it is required.\n//\nforever.load();\n\n//\n// ### function stat (logFile, script, callback)\n// #### @logFile {string} Path to the log file for this script\n// #### @logAppend {boolean} Optional. True Prevent failure if the log file exists.\n// #### @script {string} Path to the target script.\n// #### @callback {function} Continuation to pass control back to\n// Ensures that the logFile doesn't exist and that\n// the target script does exist before executing callback.\n//\nforever.stat = function (logFile, script, callback) {\n  var logAppend;\n\n  if (arguments.length === 4) {\n    logAppend = callback;\n    callback = arguments[3];\n  }\n\n  fs.stat(script, function (err, stats) {\n    if (err) {\n      return callback(new Error('script ' + script + ' does not exist.'));\n    }\n\n    return logAppend ? callback(null) : fs.stat(logFile, function (err, stats) {\n      return !err\n        ? callback(new Error('log file ' + logFile + ' exists. Use the -a or --append option to append log.'))\n        : callback(null);\n    });\n  });\n};\n\n//\n// ### function start (script, options)\n// #### @script {string} Location of the script to run.\n// #### @options {Object} Configuration for forever instance.\n// Starts a script with forever\n//\nforever.start = function (script, options) {\n  if (!options.uid) {\n    options.uid = utile.randomString(4).replace(/^\\-/, '_');\n  }\n\n  if (!options.logFile) {\n    options.logFile = forever.logFilePath(options.uid + '.log');\n  }\n\n  //\n  // Create the monitor, log events, and start.\n  //\n  var monitor = new forever.Monitor(script, options);\n  forever.logEvents(monitor);\n  return monitor.start();\n};\n\n//\n// ### function startDaemon (script, options)\n// #### @script {string} Location of the script to run.\n// #### @options {Object} Configuration for forever instance.\n// Starts a script with forever as a daemon\n//\nforever.startDaemon = function (script, options) {\n  options         = options || {};\n  options.uid     = options.uid || utile.randomString(4).replace(/^\\-/, '_');\n  options.logFile = forever.logFilePath(options.logFile || forever.config.get('logFile') || options.uid + '.log');\n  options.pidFile = forever.pidFilePath(options.pidFile || forever.config.get('pidFile') || options.uid + '.pid');\n\n  var monitor, outFD, errFD, monitorPath;\n\n  //\n  // This log file is forever's log file - the user's outFile and errFile\n  // options are not taken into account here.  This will be an aggregate of all\n  // the app's output, as well as messages from the monitor process, where\n  // applicable.\n  //\n  outFD = fs.openSync(options.logFile, 'a');\n  errFD = fs.openSync(options.logFile, 'a');\n  monitorPath = path.resolve(__dirname, '..', 'bin', 'monitor');\n\n  monitor = spawn(process.execPath, [monitorPath, script], {\n    stdio: ['ipc', outFD, errFD],\n    detached: true\n  });\n\n  monitor.on('exit', function (code) {\n    console.error('Monitor died unexpectedly with exit code %d', code);\n  });\n\n  // transmit options to daemonic(child) process, keep configuration lineage.\n  options._loadedOptions = this._loadedOptions;\n\n  monitor.send(JSON.stringify(options));\n\n  // close the ipc communication channel with the monitor\n  // otherwise the corresponding events listeners will prevent\n  // the exit of the current process (observed with node 0.11.9)\n  monitor.disconnect();\n\n  // make sure the monitor is unref() and does not prevent the\n  // exit of the current process\n  monitor.unref();\n\n  return monitor;\n};\n\n//\n// ### function startServer ()\n// #### @arguments {forever.Monitor...} A list of forever.Monitor instances\n// Starts the `forever` HTTP server for communication with the forever CLI.\n// **NOTE:** This will change your `process.title`.\n//\nforever.startServer = function () {\n  var args = Array.prototype.slice.call(arguments),\n      monitors = [],\n      callback;\n\n  args.forEach(function (a) {\n    if (Array.isArray(a)) {\n      monitors = monitors.concat(a.filter(function (m) {\n        return m instanceof forever.Monitor;\n      }));\n    }\n    else if (a instanceof forever.Monitor) {\n      monitors.push(a);\n    }\n    else if (typeof a === 'function') {\n      callback = a;\n    }\n  });\n\n  async.map(monitors, function (monitor, next) {\n    var worker = new forever.Worker({\n      monitor: monitor,\n      sockPath: forever.config.get('sockPath'),\n      exitOnStop: true\n    });\n\n    worker.start(function (err) {\n      return err ? next(err) : next(null, worker);\n    });\n  }, callback || function () {});\n};\n\n\n//\n// ### function stop (target, [format])\n// #### @target {string} Index or script name to stop\n// #### @format {boolean} Indicated if we should CLI format the returned output.\n// Stops the process(es) with the specified index or script name\n// in the list of all processes\n//\nforever.stop = function (target, format) {\n  return stopOrRestart('stop', 'stop', format, target);\n};\n\n//\n// ### function restart (target, format)\n// #### @target {string} Index or script name to restart\n// #### @format {boolean} Indicated if we should CLI format the returned output.\n// Restarts the process(es) with the specified index or script name\n// in the list of all processes\n//\nforever.restart = function (target, format) {\n  return stopOrRestart('restart', 'restart', format, target);\n};\n\n//\n// ### function stopbypid (target, format)\n// #### @pid {string} Pid of process to stop.\n// #### @format {boolean} Indicated if we should CLI format the returned output.\n// Stops the process with specified pid\n//\nforever.stopbypid = function (pid, format) {\n  // stopByPid only capable of stopping, but can't restart\n  return stopOrRestart('stop', 'stopByPid', format, pid);\n};\n\n//\n// ### function restartAll (format)\n// #### @format {boolean} Value indicating if we should format output\n// Restarts all processes managed by forever.\n//\nforever.restartAll = function (format) {\n  return stopOrRestart('restart', 'restartAll', format);\n};\n\n//\n// ### function stopAll (format)\n// #### @format {boolean} Value indicating if we should format output\n// Stops all processes managed by forever.\n//\nforever.stopAll = function (format) {\n  return stopOrRestart('stop', 'stopAll', format);\n};\n\n//\n// ### function list (format, procs, callback)\n// #### @format {boolean} If set, will return a formatted string of data\n// #### @callback {function} Continuation to respond to when complete.\n// Returns the list of all process data managed by forever.\n//\nforever.list = function (format, callback) {\n  getAllProcesses(function (err, processes) {\n    callback(err, forever.format(format, processes));\n  });\n};\n\n//\n// ### function tail (target, length, callback)\n// #### @target {string} Target script to list logs for\n// #### @options {length|stream} **Optional** Length of the logs to tail, boolean stream\n// #### @callback {function} Continuation to respond to when complete.\n// Responds with the latest `length` logs for the specified `target` process\n// managed by forever. If no `length` is supplied then `forever.config.get('loglength`)`\n// is used.\n//\nforever.tail = function (target, options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options.length = 0;\n    options.stream = false;\n  }\n\n  var that   = this,\n      length = options.length || forever.config.get('loglength'),\n      stream = options.stream || forever.config.get('logstream'),\n      blanks = function (e, i, a) { return e !== ''; },\n      title  = function (e, i, a) { return e.match(/^==>/); },\n      args   = ['-n', length],\n      logs;\n\n  if (stream) { args.unshift('-f'); }\n\n  function tailProcess(procs, next) {\n    var count = 0,\n        map   = {},\n        tail;\n\n    procs.forEach(function (proc) {\n      args.push(proc.logFile);\n      map[proc.logFile] = { pid: proc.pid, file: proc.file };\n      count++;\n    });\n\n    tail = spawn('tail', args, {\n      stdio: [null, 'pipe', 'pipe'],\n    });\n\n    tail.stdio[1].setEncoding('utf8');\n    tail.stdio[2].setEncoding('utf8');\n\n    tail.stdio[1].on('data', function (data) {\n      var chunk = data.split('\\n\\n');\n      chunk.forEach(function (logs) {\n        var logs = logs.split('\\n').filter(blanks),\n            file = logs.filter(title),\n            lines,\n            proc;\n\n        proc = file.length\n          ? map[file[0].split(' ')[1]]\n          : map[procs[0].logFile];\n\n        lines = count !== 1\n          ? logs.slice(1)\n          : logs;\n\n        lines.forEach(function (line) {\n          callback(null, { file: proc.file, pid: proc.pid, line: line });\n        });\n      });\n    });\n\n    tail.stdio[2].on('data', function (err) {\n      return callback(err);\n    });\n  }\n\n  getAllProcesses(function (err, processes) {\n    if (err) {\n      return callback(err);\n    }\n    else if (!processes) {\n      return callback(new Error('Cannot find forever process: ' + target));\n    }\n\n    var procs = forever.findByIndex(target, processes)\n      || forever.findByScript(target, processes);\n\n    if (!procs) {\n      return callback(new Error('No logs available for process: ' + target));\n    }\n\n    tailProcess(procs, callback);\n  });\n};\n\n//\n// ### function findById (id, processes)\n// #### @id {string} id of the process to find.\n// #### @processes {Array} Set of processes to find in.\n// Finds the process with the specified index.\n//\nforever.findById = function (id, processes) {\n  if (!processes) { return null; }\n\n  var procs = processes.filter(function (p) {\n    return p.id === id;\n  });\n\n  if (procs.length === 0) { procs = null; }\n  return procs;\n};\n\n//\n// ### function findByIndex (index, processes)\n// #### @index {string} Index of the process to find.\n// #### @processes {Array} Set of processes to find in.\n// Finds the process with the specified index.\n//\nforever.findByIndex = function (index, processes) {\n  var indexAsNum = parseInt(index, 10),\n      proc;\n\n  if (indexAsNum == index) {\n    proc = processes && processes[indexAsNum];\n  }\n  return proc ? [proc] : null;\n};\n\n//\n// ### function findByScript (script, processes)\n// #### @script {string} The name of the script to find.\n// #### @processes {Array} Set of processes to find in.\n// Finds the process with the specified script name.\n//\nforever.findByScript = function (script, processes) {\n  if (!processes) { return null; }\n\n  // make script absolute.\n  if (script.indexOf('/') != 0) {\n    script = path.resolve(process.cwd(), script);\n  }\n\n  var procs = processes.filter(function (p) {\n    return p.file === script || path.join(p.spawnWith.cwd, p.file) === script;\n  });\n\n  if (procs.length === 0) { procs = null; }\n  return procs;\n};\n\n//\n// ### function findByUid (uid, processes)\n// #### @uid {string} The uid of the process to find.\n// #### @processes {Array} Set of processes to find in.\n// Finds the process with the specified uid.\n//\nforever.findByUid = function (script, processes) {\n  var procs = !processes\n    ? null\n    : processes.filter(function (p) {\n      return p.uid === script;\n    });\n\n  if (procs && procs.length === 0) { procs = null; }\n  return procs;\n};\n\n//\n// ### function findByPid (pid, processes)\n// #### @pid {string} The pid of the process to find.\n// #### @processes {Array} Set of processes to find in.\n// Finds the process with the specified pid.\n//\nforever.findByPid = function (pid, processes) {\n  pid = typeof pid === 'string'\n    ? parseInt(pid, 10)\n    : pid;\n\n  var procs = processes && processes.filter(function (p) {\n    return p.pid === pid;\n  });\n\n  if (procs && procs.length === 0) { procs = null; }\n  return procs || null;\n};\n\n//\n// ### function format (format, procs)\n// #### @format {Boolean} Value indicating if processes should be formatted\n// #### @procs {Array} Processes to format\n// Returns a formatted version of the `procs` supplied based on the column\n// configuration in `forever.config`.\n//\nforever.format = function (format, procs) {\n  if (!procs || procs.length === 0) {\n    return null;\n  }\n\n  var index = 0,\n      columns = forever.config.get('columns'),\n      rows = [['   '].concat(columns)],\n      formatted;\n\n  function mapColumns(prefix, mapFn) {\n    return [prefix].concat(columns.map(mapFn));\n  }\n\n  if (format) {\n    //\n    // Iterate over the procs to see which has the\n    // longest options string\n    //\n    procs.forEach(function (proc) {\n      rows.push(mapColumns('[' + index + ']', function (column) {\n        return forever.columns[column]\n          ? forever.columns[column].get(proc)\n          : 'MISSING';\n      }));\n\n      index++;\n    });\n\n    formatted = cliff.stringifyRows(rows, mapColumns('white', function (column) {\n      return forever.columns[column]\n        ? forever.columns[column].color\n        : 'white';\n    }));\n  }\n\n  return format ? formatted : procs;\n};\n\n//\n// ### function cleanUp ()\n// Utility function for removing excess pid and\n// config, and log files used by forever.\n//\nforever.cleanUp = function (cleanLogs, allowManager) {\n  var emitter = new events.EventEmitter(),\n      pidPath = forever.config.get('pidPath');\n\n  getAllProcesses(function (err, processes) {\n    if (err) {\n      return process.nextTick(function () {\n        emitter.emit('error', err);\n      });\n    }\n    else if (cleanLogs) {\n      forever.cleanLogsSync(processes);\n    }\n\n    function unlinkProcess(proc, done) {\n      fs.unlink(path.join(pidPath, proc.uid + '.pid'), function () {\n        //\n        // Ignore errors (in case the file doesnt exist).\n        //\n\n        if (cleanLogs && proc.logFile) {\n          //\n          // If we are cleaning logs then do so if the process\n          // has a logfile.\n          //\n          return fs.unlink(proc.logFile, function () {\n            done();\n          });\n        }\n\n        done();\n      });\n    }\n\n    function cleanProcess(proc, done) {\n      if (proc.child && proc.manager) {\n        return done();\n      }\n      else if (!proc.child && !proc.manager\n        || (!proc.child && proc.manager && allowManager)\n        || proc.dead) {\n        return unlinkProcess(proc, done);\n      }\n\n      //\n      // If we have a manager but no child, wait a moment\n      // in-case the child is currently restarting, but **only**\n      // if we have not already waited for this process\n      //\n      if (!proc.waited) {\n        proc.waited = true;\n        return setTimeout(function () {\n          checkProcess(proc, done);\n        }, 500);\n      }\n\n      done();\n    }\n\n    function checkProcess(proc, next) {\n      proc.child = forever.checkProcess(proc.pid);\n      proc.manager = forever.checkProcess(proc.foreverPid);\n      cleanProcess(proc, next);\n    }\n\n    if (processes && processes.length > 0) {\n      (function cleanBatch(batch) {\n        async.forEach(batch, checkProcess, function () {\n          return processes.length > 0\n            ? cleanBatch(processes.splice(0, 10))\n            : emitter.emit('cleanUp');\n        });\n      })(processes.splice(0, 10));\n    }\n    else {\n      process.nextTick(function () {\n        emitter.emit('cleanUp');\n      });\n    }\n  });\n\n  return emitter;\n};\n\n//\n// ### function cleanLogsSync (processes)\n// #### @processes {Array} The set of all forever processes\n// Removes all log files from the root forever directory\n// that do not belong to current running forever processes.\n//\nforever.cleanLogsSync = function (processes) {\n  var root = forever.config.get('root'),\n      files = fs.readdirSync(root),\n      running,\n      runningLogs;\n\n  running = processes && processes.filter(function (p) {\n    return p && p.logFile;\n  });\n\n  runningLogs = running && running.map(function (p) {\n    return p.logFile.split('/').pop();\n  });\n\n  files.forEach(function (file) {\n    if (/\\.log$/.test(file) && (!runningLogs || runningLogs.indexOf(file) === -1)) {\n      fs.unlinkSync(path.join(root, file));\n    }\n  });\n};\n\n//\n// ### function logFilePath (logFile)\n// #### @logFile {string} Log file path\n// Determines the full logfile path name\n//\nforever.logFilePath = function (logFile, uid) {\n  return logFile && (logFile[0] === '/' || logFile[1] === ':')\n    ? logFile\n    : path.join(forever.config.get('root'), logFile || (uid || 'forever') + '.log');\n};\n\n//\n// ### function pidFilePath (pidFile)\n// #### @logFile {string} Pid file path\n// Determines the full pid file path name\n//\nforever.pidFilePath = function (pidFile) {\n  return pidFile && (pidFile[0] === '/' || pidFile[1] === ':')\n    ? pidFile\n    : path.join(forever.config.get('pidPath'), pidFile);\n};\n\n//\n// ### @function logEvents (monitor)\n// #### @monitor {forever.Monitor} Monitor to log events for\n// Logs important restart and error events to `console.error`\n//\nforever.logEvents = function (monitor) {\n  monitor.on('watch:error', function (info) {\n    forever.out.error(info.message);\n    forever.out.error(info.error);\n  });\n\n  monitor.on('watch:restart', function (info) {\n    forever.out.error('restarting script because ' + info.file + ' changed');\n  });\n\n  monitor.on('restart', function () {\n    forever.out.error('Script restart attempt #' + monitor.times);\n  });\n\n  monitor.on('exit:code', function (code, signal) {\n    forever.out.error((code !== null && code !== undefined)\n      ? 'Forever detected script exited with code: ' + code\n      : 'Forever detected script was killed by signal: ' + signal);\n  });\n};\n\n//\n// ### @columns {Object}\n// Property descriptors for accessing forever column information\n// through `forever list` and `forever.list()`\n//\nforever.columns = {\n  uid: {\n    color: 'white',\n    get: function (proc) {\n      return proc.uid;\n    }\n  },\n  id: {\n    color: 'white',\n    get: function (proc) {\n      return proc.id ? proc.id : '';\n    }\n  },\n  command: {\n    color: 'grey',\n    get: function (proc) {\n      return (proc.command || 'node').grey;\n    }\n  },\n  script: {\n    color: 'grey',\n    get: function (proc) {\n      return [proc.file].concat(proc.args).join(' ').grey;\n    }\n  },\n  forever: {\n    color: 'white',\n    get: function (proc) {\n      return proc.foreverPid;\n    }\n  },\n  pid: {\n    color: 'white',\n    get: function (proc) {\n      return proc.pid;\n    }\n  },\n  logfile: {\n    color: 'magenta',\n    get: function (proc) {\n      return proc.logFile ? proc.logFile.magenta : '';\n    }\n  },\n  dir: {\n    color: 'grey',\n    get: function (proc) {\n      return proc.sourceDir.grey;\n    }\n  },\n  uptime: {\n    color: 'yellow',\n    get: function (proc) {\n      return proc.running ? timespan.fromDates(new Date(proc.ctime), new Date()).toString().yellow : \"STOPPED\".red;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/index.js":"/*\n * index.js: Top-level include for the `forever-monitor` module.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar utile = require('utile'),\n    common = require('./forever-monitor/common');\n\nexports.kill         = common.kill;\nexports.checkProcess = common.checkProcess;\nexports.Monitor      = require('./forever-monitor/monitor').Monitor;\n\n//\n// Expose version through `pkginfo`\n//\nexports.version = require('../package').version;\n\n//\n// ### function start (script, options)\n// #### @script {string} Location of the script to run.\n// #### @options {Object} Configuration for forever instance.\n// Starts a script with forever\n//\nexports.start = function (script, options) {\n  if (!options.uid) {\n    options.uid = options.uid || utile.randomString(4).replace(/^\\-/, '_');\n  }\n\n  return new exports.Monitor(script, options).start();\n};\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/forever-monitor/common.js":"/*\n * common.js: Common methods used in `forever-monitor`.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar psTree = require('ps-tree'),\n    spawn = require('child_process').spawn;\n\n//\n// ### function checkProcess (pid, callback)\n// #### @pid {string} pid of the process to check\n// #### @callback {function} Continuation to pass control backto.\n// Utility function to check to see if a pid is running\n//\nexports.checkProcess = function (pid) {\n  if (!pid) {\n    return false;\n  }\n\n  try {\n    //\n    // Trying to kill non-existent process here raises a ESRCH - no such\n    // process exception. Also, signal 0 doesn't do no harm to a process - it\n    // only checks if sending a signal to a given process is possible.\n    //\n    process.kill(pid, 0);\n    return true;\n  }\n  catch (err) {\n    return false;\n  }\n};\n\nexports.kill = function (pid, killTree, signal, callback) {\n  signal   = signal   || 'SIGKILL';\n  callback = callback || function () {};\n\n  if (killTree && process.platform !== 'win32') {\n    psTree(pid, function (err, children) {\n      [pid].concat(\n        children.map(function (p) {\n          return p.PID;\n        })\n      ).forEach(function (tpid) {\n        try { process.kill(tpid, signal) }\n        catch (ex) { }\n      });\n\n      callback();\n    });\n  }\n  else {\n    try { process.kill(pid, signal) }\n    catch (ex) { }\n    callback();\n  }\n};","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/forever-monitor/monitor.js":"/*\n * monitor.js: Core functionality for the Monitor object.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    child_process = require('child_process'),\n    spawn = child_process.spawn,\n    broadway = require('broadway'),\n    psTree = require('ps-tree'),\n    utile = require('utile'),\n    common = require('./common'),\n    cluster = require('cluster'),\n    plugins = require('./plugins');\n\n//\n// ### function Monitor (script, options)\n// #### @script {string} Location of the target script to run.\n// #### @options {Object} Configuration for this instance.\n// Creates a new instance of forever with specified `options`.\n//\nvar Monitor = exports.Monitor = function (script, options) {\n  //\n  // Simple bootstrapper for attaching logger\n  // and watch plugins by default. Other plugins\n  // can be attached through `monitor.use(plugin, options)`.\n  //\n  function bootstrap(monitor) {\n    plugins.logger.attach.call(monitor, options);\n    if (options.watch) {\n      plugins.watch.attach.call(monitor, options);\n    }\n  }\n\n  var execPath = process.execPath,\n      self     = this;\n\n  //\n  // Setup basic configuration options\n  //\n  options               = options || {};\n  this.silent           = options.silent || false;\n  this.killTree         = options.killTree !== false;\n  this.uid              = options.uid || utile.randomString(4);\n  this.id               = options.id || false;\n  this.pidFile          = options.pidFile;\n  this.max              = options.max;\n  this.killTTL          = options.killTTL;\n  this.killSignal       = options.killSignal || 'SIGKILL';\n  this.childExists      = false;\n  this.checkFile        = options.checkFile !== false;\n  this.times            = 0;\n  this.warn             = console.error;\n\n  this.logFile          = options.logFile;\n  this.outFile          = options.outFile;\n  this.errFile          = options.errFile;\n  this.append           = options.append;\n  this.usePolling       = options.usePolling;\n  this.pollingInterval  = options.pollingInterval;\n\n  //\n  // Define some safety checks for commands with spaces\n  //\n  this.parser = options.parser || Monitor.parseCommand;\n\n  //\n  // Setup restart timing. These options control how quickly forever restarts\n  // a child process as well as when to kill a \"spinning\" process\n  //\n  this.minUptime     = typeof options.minUptime !== 'number' ? 0 : options.minUptime;\n  this.spinSleepTime = options.spinSleepTime || null;\n\n  //\n  // Special case Windows separately to decouple any\n  // future changes\n  //\n  if (process.platform === 'win32') {\n    execPath = '\"' + execPath + '\"';\n  }\n\n  if (options.options) {\n    console.warn('options.options is deprecated. Use options.args instead.');\n  }\n\n  //\n  // Setup the command to spawn and the options to pass\n  // to that command.\n  //\n  this.command   = options.command || execPath;\n  this.args      = options.args || options.options || [];\n  this.spawnWith = options.spawnWith || {};\n  this.sourceDir = options.sourceDir;\n  this.fork      = options.fork || false;\n  this.cwd       = options.cwd || process.cwd();\n  this.hideEnv   = options.hideEnv || [];\n  this._env      = options.env || {};\n  this._hideEnv  = {};\n\n  //\n  // Allow for custom stdio configuration of forked processes\n  //\n  this.stdio = options.stdio || null;\n\n  //\n  // Setup watch configuration options\n  //\n  this.watchIgnoreDotFiles = options.watchIgnoreDotFiles !== false;\n  this.watchIgnorePatterns = options.watchIgnorePatterns || [];\n  this.watchDirectory      = options.watchDirectory || this.sourceDir;\n\n  //\n  // Create a simple mapping of `this.hideEnv` to an easily indexable\n  // object\n  //\n  this.hideEnv.forEach(function (key) {\n    self._hideEnv[key] = true;\n  });\n\n  if (Array.isArray(script)) {\n    this.command = script[0];\n    this.args = script.slice(1);\n  }\n  else {\n    this.args.unshift(script);\n  }\n\n  if (this.sourceDir) {\n    this.args[0] = path.join(this.sourceDir, this.args[0]);\n  }\n\n  //\n  // Bootstrap this instance now that options\n  // have been set\n  //\n  broadway.App.call(this, { bootstrapper: { bootstrap: bootstrap } });\n};\n\n// Inherit from events.EventEmitter\nutile.inherits(Monitor, broadway.App);\n\n//\n// ### function start ([restart])\n// #### @restart {boolean} Value indicating whether this is a restart.\n// Start the process that this instance is configured for\n//\nMonitor.prototype.start = function (restart) {\n  var self = this,\n      child;\n\n  if (this.running && !restart) {\n    process.nextTick(function () {\n      self.emit('error', new Error('Cannot start process that is already running.'));\n    });\n    return this;\n  }\n\n  child = this.trySpawn();\n  if (!child) {\n    process.nextTick(function () {\n      self.emit('error', new Error('Target script does not exist: ' + self.args[0]));\n    });\n    return this;\n  }\n\n  this.ctime = Date.now();\n  this.child = child;\n  this.running = true;\n  this.isMaster = cluster.isMaster;\n\n  process.nextTick(function () {\n    self.emit(restart ? 'restart' : 'start', self, self.data);\n  });\n\n  function onMessage(msg) {\n    self.emit('message', msg);\n  }\n\n  // Re-emit messages from the child process\n  this.child.on('message', onMessage);\n\n  child.on('exit', function (code, signal) {\n    var spinning = Date.now() - self.ctime < self.minUptime;\n    child.removeListener('message', onMessage);\n    self.emit('exit:code', code, signal);\n\n    function letChildDie() {\n      self.running = false;\n      self.forceStop = false;\n      self.emit('exit', self, spinning);\n    }\n\n    function restartChild() {\n      self.forceRestart = false;\n      process.nextTick(function () {\n        self.start(true);\n      });\n    }\n\n    self.times++;\n\n    if (self.forceStop || (self.times >= self.max && !self.forceRestart)\n      || (spinning && typeof self.spinSleepTime !== 'number') && !self.forceRestart) {\n      letChildDie();\n    }\n    else if (spinning) {\n      setTimeout(restartChild, self.spinSleepTime);\n    }\n    else {\n      restartChild();\n    }\n  });\n\n  return this;\n};\n\n//\n// ### function trySpawn()\n// Tries to spawn the target Forever child process. Depending on\n// configuration, it checks the first argument of the options\n// to see if the file exists. This is useful is you are\n// trying to execute a script with an env: e.g. node myfile.js\n//\nMonitor.prototype.trySpawn = function () {\n  var run = this.parser(this.command, this.args.slice()),\n      stats;\n\n  if (/[^\\w]node$/.test(this.command) && this.checkFile && !this.childExists) {\n    try {\n      stats = fs.statSync(this.args[0]);\n      this.childExists = true;\n    }\n    catch (ex) {\n      return false;\n    }\n  }\n\n  this.spawnWith.cwd = this.spawnWith.cwd || this.cwd;\n  this.spawnWith.env = this._getEnv();\n\n  if (process.platform === 'win32') {\n    this.spawnWith.detached = true;\n  }\n\n  if (this.stdio) {\n    this.spawnWith.stdio = this.stdio;\n  }\n\n  if (this.fork) {\n    if (!this.stdio) {\n      this.spawnWith.stdio = [ 'pipe', 'pipe', 'pipe', 'ipc' ];\n    }\n    return spawn(run.command, run.args, this.spawnWith);\n  }\n\n  return spawn(run.command, run.args, this.spawnWith);\n};\n\n//\n// ### @data {Object}\n// Responds with the appropriate information about\n// this `Monitor` instance and it's associated child process.\n//\nMonitor.prototype.__defineGetter__('data', function () {\n  var self = this,\n      childData;\n\n  childData = {\n    ctime: this.ctime,\n    command: this.command,\n    file: this.args[0],\n    foreverPid: process.pid,\n    logFile: this.logFile,\n    args: this.args.slice(1),\n    pid: this.child ? this.child.pid : undefined,\n    silent: this.silent,\n    uid: this.uid,\n    id: this.id,\n    spawnWith: this.spawnWith,\n    running: this.running,\n    restarts: this.times,\n    isMaster: this.isMaster\n  };\n\n  ['pidFile', 'outFile', 'errFile', 'env', 'cwd'].forEach(function (key) {\n    if (self[key]) {\n      childData[key] = self[key];\n    }\n  });\n\n  if (this.sourceDir) {\n    childData.sourceDir = this.sourceDir;\n    childData.file = childData.file.replace(this.sourceDir + '/', '');\n  }\n\n  this.childData = childData;\n  return this.childData;\n\n  //\n  // Setup the forever process to listen to\n  // SIGINT and SIGTERM events so that we can\n  // clean up the *.pid file\n  //\n  // Remark: This should work, but the fd gets screwed up\n  //         with the daemon process.\n  //\n  // process.on('SIGINT', function () {\n  //   process.exit(0);\n  // });\n  //\n  // process.on('SIGTERM', function () {\n  //   process.exit(0);\n  // });\n  // process.on('exit', function () {\n  //   fs.unlinkSync(childPath);\n  // });\n});\n\n//\n// ### function restart ()\n// Restarts the target script associated with this instance.\n//\nMonitor.prototype.restart = function () {\n  this.times = this.times || 0;\n  this.forceRestart = true;\n\n  return !this.running\n    ? this.start(true)\n    : this.kill(false);\n};\n\n//\n// ### function stop ()\n// Stops the target script associated with this instance. Prevents it from auto-respawning\n//\nMonitor.prototype.stop = function () {\n  return this.kill(true);\n};\n\n//\n// ### function kill (forceStop)\n// #### @forceStop {boolean} Value indicating whether short circuit forever auto-restart.\n// Kills the ChildProcess object associated with this instance.\n//\nMonitor.prototype.kill = function (forceStop) {\n  var child = this.child,\n      self = this,\n      timer;\n\n  if (!child || (!this.running && !this.forceRestart)) {\n    process.nextTick(function () {\n      self.emit('error', new Error('Cannot stop process that is not running.'));\n    });\n  }\n  else {\n    //\n    // Set an instance variable here to indicate this\n    // stoppage is forced so that when `child.on('exit', ..)`\n    // fires in `Monitor.prototype.start` we can short circuit\n    // and prevent auto-restart\n    //\n    if (forceStop) {\n      this.forceStop = true;\n      //\n      // If we have a time before we truly kill forcefully, set up a timer\n      //\n      if (this.killTTL) {\n        timer = setTimeout(function () {\n          common.kill(self.child.pid, self.killTree, self.killSignal || 'SIGKILL');\n        }, this.killTTL);\n\n        child.once('exit', function () {\n          clearTimeout(timer);\n        });\n      }\n    }\n\n    child.once('exit', function () {\n      self.emit('stop', self.childData);\n      if (self.forceRestart && !self.running) {\n        self.start(true);\n      }\n    });\n\n    common.kill(this.child.pid, this.killTree, this.killSignal);\n  }\n\n  return this;\n};\n\n//\n// ### function send ()\n// Sends a message to a forked ChildProcess object associated with this instance.\n// see http://nodejs.org/api/child_process.html#child_process_child_send_message_sendhandle\n//\nMonitor.prototype.send = function (msg) {\n  var child = this.child,\n      self = this;\n\n  if (!child || !this.running) {\n    process.nextTick(function () {\n      self.emit('error', new Error('Cannot send to process that is not running.'));\n    });\n  }\n\n  if (child.send) { child.send(msg) }\n};\n\n//\n// ### function toString ()\n// Override default toString behavior and just respond\n// with JSON for this instance.\n//\nMonitor.prototype.toString = function () {\n  return JSON.stringify(this);\n};\n\n//\n// ### function inspect ()\n// Set this to null so that `util.inspect` does not\n// return `undefined`.'\n//\nMonitor.prototype.inspect = null;\n\n//\n// ### @private function _getEnv ()\n// Returns the environment variables that should be passed along\n// to the target process spawned by this instance.\n//\nMonitor.prototype._getEnv = function () {\n  var self = this,\n      merged = {};\n\n  function addKey(key, source) {\n    merged[key] = source[key];\n  }\n\n  //\n  // Mixin the key:value pairs from `process.env` and the custom\n  // environment variables in `this._env`.\n  //\n  Object.keys(process.env).forEach(function (key) {\n    if (!self._hideEnv[key]) {\n      addKey(key, process.env);\n    }\n  });\n\n  Object.keys(this._env).forEach(function (key) {\n    addKey(key, self._env);\n  });\n\n  return merged;\n};\n\n//\n// ### function parseCommand (command, args)\n// #### @command {String} Command string to parse\n// #### @args    {Array}  Additional default arguments\n//\n// Returns the `command` and the `args` parsed\n// from the command depending on the Platform.\n//\nMonitor.parseCommand = function (command, args) {\n  var match = command.match(\n    process.platform === 'win32' ? safetyChecks.windows : safetyChecks.linux\n  );\n\n  //\n  // No match means it's a bad command. This is configurable\n  // by passing a custom `parser` function into the `Monitor`\n  // constructor function.\n  //\n  if (!match) { return false; }\n\n  if (process.platform == 'win32') {\n    command = match[1] || match[2];\n    if (match[3]) {\n      args = match[3].split(' ').concat(args);\n    }\n  } else {\n    command = match[1];\n    if (match[2]) {\n      args = match[2].split(' ').concat(this.args);\n    }\n  }\n\n  return {\n    command: command,\n    args:    args\n  };\n};\n\n//\n// ### @private {Object} safetyChecks\n// Define default safety checks for commands\n// with spaces in Windows & Linux\n//\nvar safetyChecks = {\n  windows: /(?:\"(.*[^\\/])\"|(\\w+))(?:\\s(.*))?/,\n  linux:   /(.*?[^\\\\])(?: (.*)|$)/\n};\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/forever-monitor/plugins/index.js":"/*\n * index.js: Built-in plugins for forever-monitor.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nexports.logger = require('./logger');\nexports.watch  = require('./watch');","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/forever-monitor/plugins/logger.js":"/*\n * logger.js: Plugin for `Monitor` instances which adds stdout and stderr logging.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar fs = require('fs');\n\n//\n// Name the plugin\n//\nexports.name = 'logger';\n\n//\n// ### function attach (options)\n// #### @options {Object} Options for attaching to `Monitor`\n//\n// Attaches functionality for logging stdout and stderr to `Monitor` instances.\n//\nexports.attach = function (options) {\n  options = options || {};\n  var monitor = this;\n\n  if (options.outFile) {\n    monitor.stdout = options.stdout || fs.createWriteStream(options.outFile, {\n      flags: monitor.append ? 'a+' : 'w+',\n      encoding: 'utf8',\n      mode: 0644\n    });\n  }\n\n  if (options.errFile) {\n    monitor.stderr = options.stderr || fs.createWriteStream(options.errFile, {\n      flags: monitor.append ? 'a+' : 'w+',\n      encoding: 'utf8',\n      mode: 0644\n    });\n  }\n\n  monitor.on('start', startLogs);\n  monitor.on('restart', startLogs);\n  monitor.on('exit', stopLogs);\n\n  function stopLogs() {\n    if (monitor.stdout) {\n      //\n      // Remark: 0.8.x doesnt have an unpipe method\n      //\n      monitor.child.stdout.unpipe && monitor.child.stdout.unpipe(monitor.stdout);\n      monitor.stdout.destroy();\n      monitor.stdout = null;\n    }\n    //\n    // Remark: 0.8.x doesnt have an unpipe method\n    //\n    if (monitor.stderr) {\n      monitor.child.stderr.unpipe && monitor.child.stderr.unpipe(monitor.stderr);\n      monitor.stderr.destroy();\n      monitor.stderr = null;\n    }\n  }\n\n  function startLogs(child, childData) {\n    if (monitor.child) {\n      monitor.child.stdout.on('data', function onStdout(data) {\n        monitor.emit('stdout', data);\n      });\n\n      monitor.child.stderr.on('data', function onStderr(data) {\n        monitor.emit('stderr', data);\n      });\n\n      if (!monitor.silent) {\n        process.stdout.setMaxListeners(0);\n        process.stderr.setMaxListeners(0);\n        monitor.child.stdout.pipe(process.stdout, { end: false });\n        monitor.child.stderr.pipe(process.stderr, { end: false });\n      }\n\n      if (monitor.stdout) {\n        monitor.child.stdout.pipe(monitor.stdout, { end: false });\n      }\n\n      if (monitor.stderr) {\n        monitor.child.stderr.pipe(monitor.stderr, { end: false });\n      }\n    }\n  }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever-monitor/lib/forever-monitor/plugins/watch.js":"/*\n * watch.js: Plugin for `Monitor` instances which adds file watching.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    minimatch = require('minimatch'),\n    chokidar = require('chokidar');\n\nexports.name = 'watch';\n\n//\n// ### @private function _watchFilter\n// #### @file {string} File name\n// Determines whether we should restart if `file` change (@mikeal's filtering\n// is pretty messed up).\n//\nfunction watchFilter(fileName) {\n  var relFileName = path.relative(this.watchDirectory, fileName),\n      length = this.watchIgnorePatterns.length,\n      testName,\n      i;\n\n  if (this.watchIgnoreDotFiles && path.basename(fileName)[0] === '.') {\n    return false;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (this.watchIgnorePatterns[i].length > 0) {\n      testName = (this.watchIgnorePatterns[i].charAt(0) !== '/') ? relFileName : fileName;\n      if (minimatch(testName, this.watchIgnorePatterns[i], { matchBase: this.watchDirectory })) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n//\n// ### function attach (options)\n// #### @options {Object} Options for attaching to `Monitor`\n//\n// Attaches functionality for logging stdout and stderr to `Monitor` instances.\n//\nexports.attach = function () {\n  var watchDirectory = this.watchDirectory,\n      monitor = this;\n\n  fs.readFile(path.join(this.watchDirectory, '.foreverignore'), 'utf8', function (err, data) {\n    if (err) {\n      return monitor.emit('watch:error', {\n        message: 'Could not read .foreverignore file.',\n        error: err.message\n      });\n    }\n\n    Array.prototype.push.apply(monitor.watchIgnorePatterns, data.split('\\n').filter(Boolean));\n  });\n\n  var opts = {\n    usePolling: this.usePolling,\n    interval: this.pollingInterval,\n    ignoreInitial: true,\n    ignored: function(fileName) {\n      return !watchFilter.call(monitor, fileName);\n    }\n  };\n\n  // Or, ignore: function(fileName) { return !watchFilter(fileName) }\n  chokidar\n    .watch(this.watchDirectory, opts)\n    .on('all', function(f, stat) {\n      monitor.emit('watch:restart', { file: f, stat: stat });\n      monitor.restart();\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever/lib/forever/worker.js":"var events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    nssocket = require('nssocket'),\n    utile = require('utile'),\n    forever = require(path.resolve(__dirname, '..', 'forever'));\n\nvar Worker = exports.Worker = function (options) {\n  events.EventEmitter.call(this);\n  options = options || {};\n\n  this.monitor  = options.monitor;\n  this.sockPath = options.sockPath || forever.config.get('sockPath');\n  this.exitOnStop = options.exitOnStop === true;\n\n  this._socket = null;\n};\n\nutile.inherits(Worker, events.EventEmitter);\n\nWorker.prototype.start = function (callback) {\n  var self = this,\n      err;\n\n  if (this._socket) {\n    err = new Error(\"Can't start already started worker\");\n    if (callback) {\n      return callback(err);\n    }\n\n    throw err;\n  }\n\n  //\n  // Defines a simple `nssocket` protocol for communication\n  // with a parent process.\n  //\n  function workerProtocol(socket) {\n    socket.on('error', function() {\n      socket.destroy();\n    });\n\n    socket.data(['ping'], function () {\n      socket.send(['pong']);\n    });\n\n    socket.data(['data'], function () {\n      socket.send(['data'], self.monitor.data);\n    });\n\n    socket.data(['spawn'], function (data) {\n      if (!data.script) {\n        return socket.send(['spawn', 'error'], { error: new Error('No script given') });\n      }\n\n      if (self.monitor) {\n        return socket.send(['spawn', 'error'], { error: new Error(\"Already running\") });\n      }\n\n      var monitor = new (forever.Monitor)(data.script, data.args);\n      monitor.start();\n\n      monitor.on('start', function () {\n        socket.send(['spawn', 'start'], monitor.data);\n      });\n    });\n\n    socket.data(['stop'], function () {\n      function onStop(err) {\n        var args = [];\n        if (err && err instanceof Error) {\n          args.push(['stop', 'error'], { message: err.message, stack: err.stack });\n          self.monitor.removeListener('stop', onStop);\n        }\n        else {\n          args.push(['stop', 'ok']);\n          self.monitor.removeListener('error', onStop);\n        }\n\n        socket.send.apply(socket, args);\n        if (self.exitOnStop) {\n          process.exit();\n        }\n      }\n\n      self.monitor.once('stop', onStop);\n      self.monitor.once('error', onStop);\n\n      if (process.platform === 'win32') {\n        //\n        // On Windows, delete the 'symbolic' sock file. This\n        // file is used for exploration during `forever list`\n        // as a mapping to the `\\\\.pipe\\\\*` \"files\" that can't\n        // be enumerated because ... Windows.\n        //\n        fs.unlink(self._sockFile);\n      }\n\n      self.monitor.stop();\n    });\n\n    socket.data(['restart'], function () {\n      self.monitor.once('restart', function () {\n        socket.send(['restart', 'ok']);\n      });\n\n      self.monitor.restart();\n    });\n  }\n\n  function findAndStart() {\n    self._socket = nssocket.createServer(workerProtocol);\n    self._socket.on('listening', function () {\n      //\n      // `listening` listener doesn't take error as the first parameter\n      //\n      self.emit('start');\n      if (callback) {\n        callback(null, self._sockFile);\n      }\n    });\n\n    self._socket.on('error', function (err) {\n      if (err.code === 'EADDRINUSE') {\n        return findAndStart();\n      }\n      else if (callback) {\n        callback(err);\n      }\n    });\n\n    //\n    // Create a unique socket file based on the current microtime.\n    //\n    var sock = self._sockFile = path.join(self.sockPath, [\n      'worker',\n      new Date().getTime() + utile.randomString(3),\n      'sock'\n    ].join('.'));\n\n    if (process.platform === 'win32') {\n      //\n      // Create 'symbolic' file on the system, so it can be later\n      // found via \"forever list\" since the `\\\\.pipe\\\\*` \"files\" can't\n      // be enumerated because ... Windows.\n      //\n      fs.openSync(sock, 'w');\n\n      //\n      // It needs the prefix, otherwise EACCESS error happens on Windows\n      // (no .sock extension, only named pipes with .pipe prefixes)\n      //\n      sock = '\\\\\\\\.\\\\pipe\\\\' + sock;\n    }\n\n    self._socket.listen(sock);\n  }\n\n  //\n  // Attempt to start the server the first time\n  //\n  findAndStart();\n  return this;\n};\n\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever/lib/forever/cli.js":"/*\n * cli.js: Handlers for the forever CLI commands.\n *\n * (C) 2010 Charlie Robbins & the Contributors\n * MIT LICENCE\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    colors = require('colors'),\n    cliff = require('cliff'),\n    isAbsolute = require('path-is-absolute'),\n    flatiron = require('flatiron'),\n    shush = require('shush'),\n    prettyjson = require('prettyjson'),\n    clone = require('clone'),\n    objectAssign = require('object-assign'),\n    forever = require('../forever');\n\nvar cli = exports;\n\nvar help = [\n  'usage: forever [action] [options] SCRIPT [script-options]',\n  '',\n  'Monitors the script specified in the current process or as a daemon',\n  '',\n  'actions:',\n  '  start               Start SCRIPT as a daemon',\n  '  stop                Stop the daemon SCRIPT by Id|Uid|Pid|Index|Script',\n  '  stopall             Stop all running forever scripts',\n  '  restart             Restart the daemon SCRIPT',\n  '  restartall          Restart all running forever scripts',\n  '  list                List all running forever scripts',\n  '  config              Lists all forever user configuration',\n  '  set <key> <val>     Sets the specified forever config <key>',\n  '  clear <key>         Clears the specified forever config <key>',\n  '  logs                Lists log files for all forever processes',\n  '  logs <script|index> Tails the logs for <script|index>',\n  '  columns add <col>   Adds the specified column to the output in `forever list`',\n  '  columns rm <col>    Removed the specified column from the output in `forever list`',\n  '  columns set <cols>  Set all columns for the output in `forever list`',\n  '  columns reset       Resets all columns to defaults for the output in `forever list`',\n  '  cleanlogs           [CAREFUL] Deletes all historical forever log files',\n  '',\n  'options:',\n  '  -m  MAX          Only run the specified script MAX times',\n  '  -l  LOGFILE      Logs the forever output to LOGFILE',\n  '  -o  OUTFILE      Logs stdout from child script to OUTFILE',\n  '  -e  ERRFILE      Logs stderr from child script to ERRFILE',\n  '  -p  PATH         Base path for all forever related files (pid files, etc.)',\n  '  -c  COMMAND      COMMAND to execute (defaults to node)',\n  '  -a, --append     Append logs',\n  '  -f, --fifo       Stream logs to stdout',\n  '  -n, --number     Number of log lines to print',\n  '  --pidFile        The pid file',\n  '  --uid            Process uid, useful as a namespace for processes (must wrap in a string)',\n  '                   e.g. forever start --uid \"production\" app.js',\n  '                       forever stop production',\n  '  --sourceDir      The source directory for which SCRIPT is relative to',\n  '  --workingDir     The working directory in which SCRIPT will execute',\n  '  --minUptime      Minimum uptime (millis) for a script to not be considered \"spinning\"',\n  '  --spinSleepTime  Time to wait (millis) between launches of a spinning script.',\n  '  --colors         --no-colors will disable output coloring',\n  '  --plain          alias of --no-colors',\n  '  -d, --debug      Forces forever to log debug output',\n  '  -v, --verbose    Turns on the verbose messages from Forever',\n  '  -s, --silent     Run the child script silencing stdout and stderr',\n  '  -w, --watch      Watch for file changes',\n  '  --watchDirectory Top-level directory to watch from',\n  '  --watchIgnore    To ignore pattern when watch is enabled (multiple option is allowed)',\n  '  -t, --killTree   Kills the entire child process tree on `stop`',\n  '  --killSignal     Support exit signal customization (default is SIGKILL)',\n  '                   used for restarting script gracefully e.g. --killSignal=SIGTERM',\n  '  -h, --help       You\\'re staring at it',\n  '',\n  '[Long Running Process]',\n  '  The forever process will continue to run outputting log messages to the console.',\n  '  ex. forever -o out.log -e err.log my-script.js',\n  '',\n  '[Daemon]',\n  '  The forever process will run as a daemon which will make the target process start',\n  '  in the background. This is extremely useful for remote starting simple node.js scripts',\n  '  without using nohup. It is recommended to run start with -o -l, & -e.',\n  '  ex. forever start -l forever.log -o out.log -e err.log my-daemon.js',\n  '      forever stop my-daemon.js',\n  ''\n];\n\nvar app = flatiron.app;\n\nvar actions = [\n  'start',\n  'stop',\n  'stopbypid',\n  'stopall',\n  'restart',\n  'restartall',\n  'list',\n  'config',\n  'set',\n  'clear',\n  'logs',\n  'columns',\n  'cleanlogs'\n];\n\nvar argvOptions = cli.argvOptions = {\n  'command':   {alias: 'c'},\n  'errFile':   {alias: 'e'},\n  'logFile':   {alias: 'l'},\n  'killTree':  {alias: 't', boolean: true},\n  'append':    {alias: 'a', boolean: true},\n  'fifo':      {alias: 'f', boolean: true},\n  'number':    {alias: 'n'},\n  'max':       {alias: 'm'},\n  'outFile':   {alias: 'o'},\n  'path':      {alias: 'p'},\n  'help':      {alias: 'h'},\n  'silent':    {alias: 's', boolean: true},\n  'verbose':   {alias: 'v', boolean: true},\n  'watch':     {alias: 'w', boolean: true},\n  'debug':     {alias: 'd', boolean: true},\n  'plain':     {boolean: true},\n  'uid':       {alias: 'u'}\n};\n\napp.use(flatiron.plugins.cli, {\n  argv: argvOptions,\n  usage: help\n});\n\nvar reserved = ['root', 'pidPath'];\n\n//\n// ### @private function (file, options, callback)\n// #### @file {string} Target script to start\n// #### @options {Object} Options to start the script with\n// #### @callback {function} Continuation to respond to when complete.\n// Helper function that sets up the pathing for the specified `file`\n// then stats the appropriate files and responds.\n//\nfunction tryStart(file, options, callback) {\n  var fullLog, fullScript;\n\n  if (options.path) {\n    forever.config.set('root', options.path);\n    forever.root = options.path;\n  }\n\n  fullLog = forever.logFilePath(options.logFile, options.uid);\n  fullScript = path.join(options.sourceDir, file);\n\n  forever.stat(fullLog, fullScript, options.append, function (err) {\n    if (err) {\n      forever.log.error('Cannot start forever');\n      forever.log.error(err.message);\n      process.exit(-1);\n    }\n\n    callback();\n  });\n}\n\n//\n// ### @private function updateConfig (updater)\n// #### @updater {function} Function which updates the forever config\n// Helper which runs the specified `updater` and then saves the forever\n// config to `forever.config.get('root')`.\n//\nfunction updateConfig(updater) {\n  updater();\n  forever.config.save(function (err) {\n    if (err) {\n      return forever.log.error('Error saving config: ' + err.message);\n    }\n\n    cli.config();\n    var configFile = path.join(forever.config.get('root'), 'config.json');\n    forever.log.info('Forever config saved: ' + configFile.yellow);\n  });\n}\n\n//\n// ### @private function checkColumn (name)\n// #### @name {string} Column to check\n// Checks if column `name` exists\n//\nfunction checkColumn(name) {\n  if (!forever.columns[name]) {\n    forever.log.error('Unknown column: ' + name.magenta);\n    return false;\n  }\n  return true;\n}\n\n//\n// ### function getOptions (file)\n// #### @file {string} File to run. **Optional**\n// Returns `options` object for use with `forever.start` and\n// `forever.startDaemon`\n//\nvar getOptions = cli.getOptions = function (file) {\n  var options = {},\n      absFile = isAbsolute(file) ? file : path.resolve(process.cwd(), file),\n      configKeys = [\n        'pidFile', 'logFile', 'errFile', 'watch', 'minUptime', 'append',\n        'silent', 'outFile', 'max', 'command', 'path', 'spinSleepTime',\n        'sourceDir', 'workingDir', 'uid', 'watchDirectory', 'watchIgnore',\n        'killTree', 'killSignal', 'id'\n      ],\n      specialKeys = ['script', 'args'],\n      configs;\n\n  //\n  // Load JSON configuration values\n  //\n  if (path.extname(file) === '.json') {\n    configs = shush(absFile);\n    configs = !Array.isArray(configs) ? [configs] : configs;\n\n    configs = configs.map(function (conf) {\n      var mut = Object.keys(conf)\n        .reduce(function (acc, key) {\n          if (~configKeys.indexOf(key) || ~specialKeys.indexOf(key)) {\n            acc[key] = conf[key];\n          }\n\n          return acc;\n        }, {});\n\n      if (!mut.script) {\n        forever.log.error('\"script\" option required in JSON configuration files');\n        console.log(prettyjson.render(mut));\n        process.exit(1);\n      }\n\n      return mut;\n    });\n  } else {\n    options.script = file;\n  }\n\n  //\n  // First isolate options which should be passed to file\n  //\n  options.args = process.argv.splice(process.argv.indexOf(file) + 1);\n\n  //\n  // Now we have to force optimist to reparse command line options because\n  // we've removed some before.\n  //\n  app.config.stores.argv.store = {};\n  app.config.use('argv', argvOptions);\n\n  configKeys.forEach(function (key) {\n    options[key] = app.config.get(key);\n  });\n\n  options.watchIgnore         = options.watchIgnore || [];\n  options.watchIgnorePatterns = Array.isArray(options.watchIgnore)\n    ? options.watchIgnore\n    : [options.watchIgnore];\n\n  if (!options.minUptime) {\n    forever.log.warn('--minUptime not set. Defaulting to: 1000ms');\n    options.minUptime = 1000;\n  }\n\n  if (!options.spinSleepTime) {\n    forever.log.warn([\n      '--spinSleepTime not set. Your script',\n      'will exit if it does not stay up for',\n      'at least ' + options.minUptime + 'ms'\n    ].join(' '));\n  }\n\n  function assignSpawnWith(options) {\n    options.sourceDir  = options.sourceDir  || (file && file[0] !== '/' ? process.cwd() : '/');\n    options.workingDir = options.workingDir || options.sourceDir;\n    options.spawnWith  = { cwd: options.workingDir };\n    return options;\n  }\n\n  if (configs && configs.length) {\n    return configs.map(function (conf) {\n      return assignSpawnWith(objectAssign(clone(options), conf));\n    });\n  }\n\n  return [assignSpawnWith(options)];\n};\n\n//\n// ### function cleanLogs\n// Deletes all historical forever log files\n//\napp.cmd('cleanlogs', cli.cleanLogs = function () {\n  forever.log.silly('Tidying ' + forever.config.get('root'));\n  forever.cleanUp(true).on('cleanUp', function () {\n    forever.log.silly(forever.config.get('root') + ' tidied.');\n  });\n});\n\n//\n// ### function start (file)\n// #### @file {string} Location of the script to spawn with forever\n// Starts a forever process for the script located at `file` as daemon\n// process.\n//\napp.cmd(/start (.+)/, cli.startDaemon = function () {\n  var file = app.argv._[1],\n      options = getOptions(file);\n\n  options.forEach(function (o) {\n    forever.log.info('Forever processing file: ' + o.script.grey);\n    tryStart(o.script, o, function () {\n      forever.startDaemon(o.script, o);\n    });\n  });\n\n});\n\n//\n// ### function stop (file)\n// #### @file {string} Target forever process to stop\n// Stops the forever process specified by `file`.\n//\napp.cmd(/stop (.+)/, cli.stop = function (file) {\n  var runner = forever.stop(file, true);\n\n  runner.on('stop', function (process) {\n    forever.log.info('Forever stopped process:' + '\\n' + process);\n  });\n\n  runner.on('error', function (err) {\n    forever.log.error('Forever cannot find process with id: ' + file);\n    process.exit(1);\n  });\n});\n\n//\n// ### function stopbypid (pid)\n// Stops running forever process by pid.\n//\napp.cmd(/stopbypid (.+)/, cli.stopbypid = function (pid) {\n  forever.log.warn('Deprecated, try `forever stop ' + pid + '` instead.');\n  cli.stop(pid);\n});\n\n//\n// ### function stopall ()\n// Stops all currently running forever processes.\n//\napp.cmd('stopall', cli.stopall = function () {\n  var runner = forever.stopAll(true);\n  runner.on('stopAll', function (processes) {\n    if (processes) {\n      forever.log.info('Forever stopped processes:');\n      processes.split('\\n').forEach(function (line) {\n        forever.log.data(line);\n      });\n    }\n    else {\n      forever.log.info('No forever processes running');\n    }\n  });\n\n  runner.on('error', function () {\n    forever.log.info('No forever processes running');\n  });\n});\n\n//\n// ### function restartall ()\n// Restarts all currently running forever processes.\n//\napp.cmd('restartall', cli.restartAll = function () {\n  var runner = forever.restartAll(true);\n  runner.on('restartAll', function (processes) {\n    if (processes) {\n      forever.log.info('Forever restarted processes:');\n      processes.split('\\n').forEach(function (line) {\n        forever.log.data(line);\n      });\n    }\n    else {\n      forever.log.info('No forever processes running');\n    }\n  });\n\n  runner.on('error', function () {\n    forever.log.info('No forever processes running');\n  });\n});\n\n//\n// ### function restart (file)\n// #### @file {string} Target process to restart\n// Restarts the forever process specified by `file`.\n//\napp.cmd(/restart (.+)/, cli.restart = function (file) {\n  var runner = forever.restart(file, true);\n  runner.on('restart', function (processes) {\n    if (processes) {\n      forever.log.info('Forever restarted process(es):');\n      processes.split('\\n').forEach(function (line) {\n        forever.log.data(line);\n      });\n    }\n    else {\n      forever.log.info('No forever processes running');\n    }\n  });\n\n  runner.on('error', function (err) {\n    forever.log.error('Error restarting process: ' + file.grey);\n    forever.log.error(err.message);\n    process.exit(1);\n  });\n});\n\n//\n// ### function list ()\n// Lists all currently running forever processes.\n//\napp.cmd('list', cli.list = function () {\n  forever.list(true, function (err, processes) {\n    if (processes) {\n      forever.log.info('Forever processes running');\n      processes.split('\\n').forEach(function (line) {\n        forever.log.data(line);\n      });\n    }\n    else {\n      forever.log.info('No forever processes running');\n    }\n  });\n});\n\n//\n// ### function config ()\n// Lists all of the configuration in `~/.forever/config.json`.\n//\napp.cmd('config', cli.config = function () {\n  var keys = Object.keys(forever.config.store),\n      conf = cliff.inspect(forever.config.store);\n\n  if (keys.length <= 2) {\n    conf = conf.replace(/\\{\\s/, '{ \\n')\n               .replace(/\\}/, '\\n}')\n               .replace('\\\\033[90m', '  \\\\033[90m')\n               .replace(/, /ig, ',\\n  ');\n  }\n  else {\n    conf = conf.replace(/\\n\\s{4}/ig, '\\n  ');\n  }\n\n  conf.split('\\n').forEach(function (line) {\n    forever.log.data(line);\n  });\n});\n\n//\n// ### function set (key, value)\n// #### @key {string} Key to set in forever config\n// #### @value {string} Value to set for `key`\n// Sets the specified `key` / `value` pair in the\n// forever user config.\n//\napp.cmd(/set ([\\w-_]+) (.+)/, cli.set = function (key, value) {\n  updateConfig(function () {\n    forever.log.info('Setting forever config: ' + key.grey);\n    forever.config.set(key, value);\n  });\n});\n\n//\n// ### function clear (key)\n// #### @key {string} Key to remove from `~/.forever/config.json`\n// Removes the specified `key` from the forever user config.\n//\napp.cmd('clear :key', cli.clear = function (key) {\n  if (reserved.indexOf(key) !== -1) {\n    forever.log.warn('Cannot clear reserved config: ' + key.grey);\n    forever.log.warn('Use `forever set ' + key + '` instead');\n    return;\n  }\n\n  updateConfig(function () {\n    forever.log.info('Clearing forever config: ' + key.grey);\n    forever.config.clear(key);\n  });\n});\n\n//\n// ### function logs (target)\n// #### @target {string} Target script or index to list logs for\n// Displays the logs using `tail` for the specified `target`.\n//\napp.cmd('logs :index', cli.logs = function (index) {\n  var options = {\n      stream: app.argv.fifo,\n      length: app.argv.number\n  };\n\n  forever.tail(index, options, function (err, log) {\n    if (err) {\n      return forever.log.error(err.message);\n    }\n\n    forever.log.data(log.file.magenta + ':' + log.pid + ' - ' + log.line);\n\n  });\n});\n\n//\n// ### function logFiles ()\n// Display log files for all running forever processes.\n//\napp.cmd('logs', cli.logFiles = function (index) {\n  if (typeof index !== 'undefined') {\n    return;\n  }\n\n  var rows = [['   ', 'script', 'logfile']];\n  index = 0;\n\n  forever.list(false, function (err, processes) {\n    if (!processes) {\n      return forever.log.warn('No forever logfiles in ' + forever.config.get('root').magenta);\n    }\n\n    forever.log.info('Logs for running Forever processes');\n    rows = rows.concat(processes.map(function (proc) {\n      return ['[' + index++ + ']', proc.file.grey, proc.logFile.magenta];\n    }));\n\n    cliff.putRows('data', rows, ['white', 'grey', 'magenta']);\n  });\n});\n\n\napp.cmd('columns add :name', cli.addColumn = function (name) {\n  if (checkColumn(name)) {\n    var columns = forever.config.get('columns');\n\n    if (~columns.indexOf(name)) {\n      return forever.log.warn(name.magenta + ' already exists in forever');\n    }\n\n    forever.log.info('Adding column: ' + name.magenta);\n    columns.push(name);\n\n    forever.config.set('columns', columns);\n    forever.config.saveSync();\n  }\n});\n\napp.cmd('columns rm :name', cli.rmColumn = function (name) {\n  if (checkColumn(name)) {\n    var columns = forever.config.get('columns');\n\n    if (!~columns.indexOf(name)) {\n      return forever.log.warn(name.magenta + ' doesn\\'t exist in forever');\n    }\n\n    forever.log.info('Removing column: ' + name.magenta);\n    columns.splice(columns.indexOf(name), 1);\n\n    forever.config.set('columns', columns);\n    forever.config.saveSync();\n  }\n});\n\napp.cmd(/columns set (.*)/, cli.setColumns = function (columns) {\n  forever.log.info('Setting columns: ' + columns.magenta);\n\n  forever.config.set('columns', columns.split(' '));\n  forever.config.saveSync();\n});\n\napp.cmd('columns reset', cli.resetColumns = function () {\n  var columns = 'uid command script forever pid logfile uptime';\n\n  forever.log.info('Setting columns: ' + columns.magenta);\n\n  forever.config.set('columns', columns.split(' '));\n  forever.config.saveSync();\n});\n\n//\n// ### function help ()\n// Shows help\n//\napp.cmd('help', cli.help = function () {\n  util.puts(help.join('\\n'));\n});\n\n//\n// ### function start (file)\n// #### @file {string} Location of the script to spawn with forever\n// Starts a forever process for the script located at `file` as non-daemon\n// process.\n//\n// Remark: this regex matches everything. It has to be added at the end to\n// make executing other commands possible.\n//\ncli.run = function () {\n  var file = app.argv._[0],\n      options = getOptions(file);\n\n  options.forEach(function (o) {\n    tryStart(o.script, o, function () {\n      var monitor = forever.start(o.script, o);\n      monitor.on('start', function () {\n        forever.startServer(monitor);\n      });\n    });\n  });\n};\n\ncli.start = function () {\n  if (app.argv.version) {\n    return console.log('v' + forever.version);\n  }\n\n  //\n  // Check for --no-colors/--colors and --plain option\n  //\n  if ((typeof app.argv.colors !== 'undefined' && !app.argv.colors) || app.argv.plain) {\n    colors.mode = 'none';\n  }\n\n  if (app.config.get('help')) {\n    return util.puts(help.join('\\n'));\n  }\n\n  app.init(function () {\n    if (app.argv._.length && actions.indexOf(app.argv._[0]) === -1) {\n      return cli.run();\n    }\n\n    app.start();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-forever/node_modules/forever/bin/forever":"#!/usr/bin/env node\n\nrequire('../lib/forever').cli.start();\n"}